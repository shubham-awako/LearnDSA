# Happy Number

## Problem Statement

Write an algorithm to determine if a number `n` is happy.

A happy number is a number defined by the following process:
- Starting with any positive integer, replace the number by the sum of the squares of its digits.
- Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.
- Those numbers for which this process ends in 1 are happy.

Return `true` if `n` is a happy number, and `false` if not.

**Example 1:**
```
Input: n = 19
Output: true
Explanation:
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
```

**Example 2:**
```
Input: n = 2
Output: false
```

**Constraints:**
- `1 <= n <= 2^31 - 1`

## Concept Overview

This problem involves determining if a number is a happy number. The key insight is to detect cycles in the sequence of numbers generated by the process.

## Solutions

### 1. Best Optimized Solution - Floyd's Cycle-Finding Algorithm

Use Floyd's Cycle-Finding Algorithm (also known as the "tortoise and hare" algorithm) to detect cycles in the sequence of numbers.

```python
def isHappy(n):
    def get_next(num):
        total_sum = 0
        while num > 0:
            digit = num % 10
            total_sum += digit ** 2
            num //= 10
        return total_sum
    
    slow = n
    fast = get_next(n)
    
    while fast != 1 and slow != fast:
        slow = get_next(slow)
        fast = get_next(get_next(fast))
    
    return fast == 1
```

**Time Complexity:** O(log n) - The number of digits in n is log n, and each iteration of the algorithm takes O(log n) time to compute the sum of squares of digits.
**Space Complexity:** O(1) - We only use a constant amount of extra space.

### 2. Alternative Solution - Using a Set

Use a set to keep track of numbers we've seen before to detect cycles.

```python
def isHappy(n):
    def get_next(num):
        total_sum = 0
        while num > 0:
            digit = num % 10
            total_sum += digit ** 2
            num //= 10
        return total_sum
    
    seen = set()
    while n != 1 and n not in seen:
        seen.add(n)
        n = get_next(n)
    
    return n == 1
```

**Time Complexity:** O(log n) - The number of digits in n is log n, and each iteration of the algorithm takes O(log n) time to compute the sum of squares of digits.
**Space Complexity:** O(log n) - In the worst case, we need to store log n numbers in the set.

### 3. Alternative Solution - Mathematical Approach

Use the fact that for any starting number, the sequence either reaches 1 or enters a cycle that includes 4.

```python
def isHappy(n):
    def get_next(num):
        total_sum = 0
        while num > 0:
            digit = num % 10
            total_sum += digit ** 2
            num //= 10
        return total_sum
    
    while n != 1 and n != 4:
        n = get_next(n)
    
    return n == 1
```

**Time Complexity:** O(log n) - The number of digits in n is log n, and each iteration of the algorithm takes O(log n) time to compute the sum of squares of digits.
**Space Complexity:** O(1) - We only use a constant amount of extra space.

## Solution Choice and Explanation

The Floyd's Cycle-Finding Algorithm solution (Solution 1) is the best approach for this problem because:

1. **Efficiency**: It achieves O(log n) time complexity and O(1) space complexity, which is optimal for this problem.

2. **Elegance**: It's a clever application of Floyd's Cycle-Finding Algorithm, which is a well-known algorithm for detecting cycles in sequences.

3. **Generality**: It works for any starting number and doesn't rely on specific properties of the sequence.

The key insight of this approach is to use two pointers, a slow pointer and a fast pointer, to detect cycles in the sequence of numbers generated by the process. The slow pointer moves one step at a time, while the fast pointer moves two steps at a time. If there's a cycle, the fast pointer will eventually catch up to the slow pointer. If there's no cycle and the sequence reaches 1, the fast pointer will reach 1 first.

For example, let's trace through the algorithm for n = 19:

1. Initialize slow = 19, fast = get_next(19) = 82

2. Iterate until fast == 1 or slow == fast:
   - slow = get_next(19) = 82, fast = get_next(get_next(82)) = get_next(68) = 100
   - slow = get_next(82) = 68, fast = get_next(get_next(100)) = get_next(1) = 1
   - fast == 1, so break

3. Return fast == 1, which is true

For n = 2:

1. Initialize slow = 2, fast = get_next(2) = 4

2. Iterate until fast == 1 or slow == fast:
   - slow = get_next(2) = 4, fast = get_next(get_next(4)) = get_next(16) = 37
   - slow = get_next(4) = 16, fast = get_next(get_next(37)) = get_next(58) = 89
   - slow = get_next(16) = 37, fast = get_next(get_next(89)) = get_next(145) = 42
   - slow = get_next(37) = 58, fast = get_next(get_next(42)) = get_next(20) = 4
   - slow = get_next(58) = 89, fast = get_next(get_next(4)) = get_next(16) = 37
   - slow = get_next(89) = 145, fast = get_next(get_next(37)) = get_next(58) = 89
   - slow = get_next(145) = 42, fast = get_next(get_next(89)) = get_next(145) = 42
   - slow == fast == 42, so break

3. Return fast == 1, which is false

The Using a Set solution (Solution 2) is also efficient but uses more space. The Mathematical Approach solution (Solution 3) is also efficient and uses constant space, but it relies on the specific property that the sequence either reaches 1 or enters a cycle that includes 4, which may not be obvious or generalizable.

In an interview, I would first mention the Floyd's Cycle-Finding Algorithm solution as the most space-efficient approach for this problem, and then discuss the Using a Set solution as an alternative if asked for a different approach. I would also mention the Mathematical Approach solution if asked for a more specific approach for this problem.
